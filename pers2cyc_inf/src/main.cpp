#include <iostream>
#include <vector>
#include <boost/program_options.hpp> 
#include "utils.h"
#include "inf_pers2cyc.h"
#include "tests.h"

struct Options {
    std::string filename;
    int start_interval;
    int num_intervals;
    IntervSortType interv_sort_type;
    bool as_filt_file;
    ExecOptions exec_ops;
};

bool parseOptions(int argc, char** argv, Options* ops);

int main(int argc, char** argv) {
    // testBMCubeComplex();
    // return 0;

    ComplexType cmplx_type = CUBE_CMPLX;
    Options ops;
    if (!parseOptions(argc, argv, &ops)) {
        return -1;
    }

    if (!ops.as_filt_file) {
        cout << endl << "perseus file: " << ops.filename << endl;
    } else {
        cout << endl << "filt file: " << ops.filename << endl;
    }
    cout << "start interval: " << ops.start_interval << endl;
    cout << "num of intervals: " << ops.num_intervals << endl;
    if (!ops.as_filt_file) {
        cout << "intervals sort by: " << (ops.interv_sort_type == BY_FILT_INDEX ?
            "filtration index" : "function value") << endl;
    }

    std::string filt_fname;

    if (!ops.as_filt_file) {
        if (cmplx_type == CUBE_CMPLX) {
            computePersistenceCube(
                ops.filename, ops.interv_sort_type, ops.exec_ops, &filt_fname);
        }    
    } else {
        filt_fname = ops.filename;
    }

    infPers2CycsFromFile(filt_fname, cmplx_type, 
        ops.start_interval, ops.num_intervals, ops.exec_ops);
}

bool parseOptions(int argc, char** argv, Options* ops) {
    try { 
        std::string intervals_str;

        namespace po = boost::program_options; 
        po::options_description shown_desc("Options"); 
        shown_desc.add_options() 
            ("int,i", po::value<std::string>(&intervals_str), 
            "Range of intervals whose persistent cycles will be computed. "
            "E.g., '--int 10' means to compute persistent cycles for the 0th " 
            "to 9th intervals and '--int 5,10' means to compute "
            "persistent cycles for the 5th to 14th intervals. "
            "Intervals are sorted by length.\n")
            ("idx", 
            "Specify that the length of the intervals used for sorting is "
            "the difference of the filtration indices. Difference of the scalar values "
            "is used by default.\n")
            ("im", "Output some intermediate meshes generated by the program for computing\n") 
            ("verbose,v", "Print verbosity messages while executing\n") 
            ("help,h", "Print help messages\n");

        po::options_description hidden_desc("Hidden options"); 
        hidden_desc.add_options() 
            ("filt", "")
            ("filename", po::value<std::string>(&ops->filename)->required(), "filename");

        po::options_description desc("All options"); 
        desc.add(shown_desc).add(hidden_desc);

        po::positional_options_description positional_options; 
        positional_options.add("filename", 1);

        po::variables_map vm;

        try { 
            po::store(po::command_line_parser(argc, argv).
                options(desc).positional(positional_options).run(), vm);

            if (vm.count("help")) { 
                cout << endl << "Compute persistent 2-cycles for infinite intervals" << endl << endl
                    << "USAGE: ./pers2cyc_inf [OPTIONS] [FILENAME]" << endl << endl
                    << shown_desc; 
                exit(0); 
            }

            po::notify(vm);

        } catch(boost::program_options::required_option& e) {  

            cout << "ERROR: " << e.what() << endl << endl; 
            return false; 

        } catch(boost::program_options::error& e) { 

            cout << "ERROR: " << e.what() << endl << endl; 
            return false; 

        } 

        ops->exec_ops.verbose = false;
        if (vm.count("verbose")) {
             ops->exec_ops.verbose = true;
        }

        ops->exec_ops.write_intem = false;
        if (vm.count("im")) {
             ops->exec_ops.write_intem = true;
        }

        ops->as_filt_file = false;
        if (vm.count("filt")) {
             ops->as_filt_file = true;
        }

        ops->interv_sort_type = BY_FUNC_VAL;
        if (vm.count("idx")) {
             ops->interv_sort_type = BY_FILT_INDEX;
        }

        std::string first_str, second_str;
        splitStrLast(intervals_str, ",", &first_str, &second_str);
        // cout << first_str << "," << first_str << endl;

        try {
            if (second_str.compare("") == 0) {
                ops->start_interval = 0;
                ops->num_intervals = std::stoi(first_str);
            } else {
                ops->start_interval = std::stoi(first_str);
                ops->num_intervals = std::stoi(second_str);
            }
        } catch(std::exception& e) { 

            cout << "ERROR: interval range not valid"<< endl;
            return false;
        }

    } catch(std::exception& e) { 

        cout << "Unhandled Exception reached the top of main: " 
                  << e.what() << ", application will now exit" << endl; 
        return false;
    } 

    return true;
}




